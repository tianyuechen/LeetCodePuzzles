class Solution {
    private int[] roots;
    private int[] ranks;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        // initialize union find
        int n = graph.length;
        roots = new int[n];
        ranks = new int[n];
        for (int i = 0; i < n; i++)
            roots[i] = i;
        Arrays.fill(ranks, 1);
        // union find to find connected components
        for (int node = 0; node < n - 1; node++) {
            for (int neighbor = node + 1; neighbor < graph.length; neighbor++) {
                if (graph[node][neighbor] == 1) {
                    union(node, neighbor);
                }
            }
        }
        // count number of infected nodes in connected components
        Map<Integer, Integer> numInfected = new HashMap<>();
        int[] initialRoots = new int[initial.length];
        for (int i = 0; i < initial.length; i++) {
            int root = find(initial[i]);
            initialRoots[i] = root;
            numInfected.put(root, 1 + numInfected.getOrDefault(root, 0));
        }

        int best = -1;
        int res = -1;
        for (int i = 0; i < initial.length; i++) {
            int source = initial[i];
            int root = initialRoots[i];
            int numSaved = 0;
            // a connected component can be saved iff it has only 1 infected node
            if (numInfected.get(root) == 1) {
                numSaved = ranks[root];
            }
            if (numSaved > best || (numSaved == best && source < res)) {
                best = numSaved;
                res = source;
            }
        }
        return res;
    }

    private void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);
        if (rootA == rootB)
            return;
        if (ranks[a] < ranks[b]) {
            roots[rootA] = rootB;
            ranks[rootB] += ranks[rootA];
        } else {
            roots[rootB] = rootA;
            ranks[rootA] += ranks[rootB];
        }
    }

    private int find(int i) {
        while (roots[i] != i) {
            i = roots[i];
        }
        return i;
    }
}