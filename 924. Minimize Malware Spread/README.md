# Minimize Malware Spread
## Topics
Union find, Hashmap, Graph, Array

## Complexity
Time: $O(Elog(E))$ where E is the number of edges in `graph`

Space: $O(n)$
## Insights
1. An infected node will infect all nodes in its connected component.
2. If a connected component has at least 2 infected nodes, removing any infectewd node won't affect `M(initial)`.
3. Union find can quickly separate an undirected graph into connected components.

## Helper functions
### find
A tree-based union-find helper that returns the root of a node.
```java
private int find(int i) {
    while (roots[i] != i) {
        i = roots[i];
    }
    return i;
}
```
### union
A tree-based union-find helper that merges the smaller (in size) tree under the larger one. Although usually `ranks` stores the height of trees, `ranks` here stores the size of trees because we need to find the size of each connected component.
```java
private void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);
    if (rootA == rootB) return;
    if (ranks[a] < ranks[b]) {
        roots[rootA] = rootB;
        ranks[rootB] += ranks[rootA];
    } else {
        roots[rootB] = rootA;
        ranks[rootA] += ranks[rootB];
    }
}
```

## Main function
1. Initialize `roots` and `ranks` as `n` individual trees.
    ```java
    int n = graph.length;
    roots = new int[n];
    ranks = new int[n];
    for (int i = 0; i < n; i++) roots[i] = i;
    Arrays.fill(ranks, 1);
    ```
2. Union find to find connected components of `graph`.
    ```java
    for (int node = 0; node < n - 1; node++) {
        for (int neighbor = node + 1; neighbor < graph.length; neighbor++) {
            if (graph[node][neighbor] == 1) {
                union(node, neighbor);
            }
        }
    }
    ```
3. Count the number of infected nodes in each connected component. Also caches the roots of each infected node for reuse.
    ```java
    Map<Integer, Integer> numInfected = new HashMap<>();
    int[] initialRoots = new int[initial.length];
    for (int i = 0; i < initial.length; i++) {
        int root = find(initial[i]);
        initialRoots[i] = root;
        numInfected.put(root, 1 + numInfected.getOrDefault(root, 0));
    }
    ```
4. Try removing each infected node, which either saves no nodes or saves its entire connected components. Find the infected node that can save the most nodes.
    ```java
    int best = -1;
    int res = -1;
    for (int i = 0; i < initial.length; i++) {
        int source = initial[i];
        int root = initialRoots[i];
        int numSaved = 0;
        if (numInfected.get(root) == 1) {
            numSaved = ranks[root];
        }
        if (numSaved > best || (numSaved == best && source < res)) {
            best = numSaved;
            res = source;
        }
    }
    return res;
    ```