# Minimum Moves to Pick K Ones
## Topics
Array, Greedy, Sliding Window

## Complexity
Time: $O(n)$

Space: $O(n)$
## Insights
1. Split the problem into two phases: generating `1`'s and collecting them.
2. The `k` `1`'s to be collected either already exist in `nums`, or they have be generated by flipping a `0` using **move 1**.
3. Consider `aliceIndex` as a central collecting index in `nums` that collects `1`'s using **move 2**.
4. You can collect a one in
   - 0 moves if it's at `aliceIndex`
   - 1 move if it's next to `aliceIndex`
   - 2 moves by flipping a `0` next to `aliceIndex` (**move 1**) and collect it (**move 2**)
   - 2+ moves if you run out of **move 1** and only apply **move 2**
5. If we generate `numGenerated` `1`'s, it takes `2 * numGenerated` moves to collect them.
6. The remaining `k - numGenerated` `1`'s must be continuous subarray in the `nums` and `aliceIndex` will be the median.

## Helper functions
### Collect

Given `indices`, an array of indices of `1`'s in `nums`, return the minimum moves (`minMoves`) to collect `k` `1`'s.

If `indices.size() == k`, then `minMoves` is the sum of `|index - median|` for each `index` in `indices`.

If `indices.size() > k`, then we have to slide the subarray from `indices[0:k]` to `indices[-k:]`.

How does sliding affect `minMoves`?
```java
/*
 * m = k/2
 * 0 1 2 .... m ....... k-1
 *  \ \ \      \           \  
 *   1 2 3 .. m m+1 ... k-1 k
*/
```
1. Index 0 no longer exists, so we subtract `indices[m] - indices[0]`.
2. Index k is added, so we add `indices[k] - indices[m+1]`.
3. Indices 1 through m's distance increases by `indices[m+1] - indices[m]`.
4. Indices m+1 through k-1's distance decreases by `indices[m+1] - indices[m]`.
5. We can comine step 3 and 4 above into `minMoves += (2*m+1-k)  * (indices[m+1] - indices[m]`

## Main function
1. Find indices of all `1`'s in `nums`. Handle an obvious edge case where there are no `1`'s.
    ```java
    // get indices of 1's in nums
    List<Integer> ones = new ArrayList<>(k);
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == 1) ones.add(i);
    }
    // edge case: no 1's in nums
    if (ones.size() == 0) return 2 * k;
    Integer[] indices = ones.toArray(new Integer[ones.size()]);
    ```
2. Then find the combination of `numGen` generated `1`'s and `numCollect` existing `1`'s that produces the minimum moves.
3. Although we want use **move 1** as much as possible (i.e., maximize `numGen`), it is possible for `1` to appear **at** and **next to** `aliceIndex`. For example, `nums = [1,1,1,0], k = 3, maxChanges = 3` requires 2 moves and all `1`'s are collected using **move 2**. So we can leave **at most 3** `1`'s to `collect`. So we use the find the `minMoves` by only comparing 4 combinations of `numGen` and `numCollect`.
    ```java
    long minMoves = Long.MAX_VALUE;
    // iterate through all combinatinos of numGen + numCollect = k
    maxChanges = Math.min(maxChanges, k);
    for (int numGen = maxChanges; numGen >= maxChanges - 3; numGen--) {
        int numCollect = k - numGen;
        if (numGen >= 0 && 0 < numCollect && numCollect <= indices.length) {
            minMoves = Math.min(minMoves, numGen * 2 + collect(indices, numCollect));
        }
    }
    return minMoves;
    ```